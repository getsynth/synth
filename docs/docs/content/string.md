Synth's `string` generator type regroups many different useful functionalities, from the ability to generate sentences
from a regular expression to dates and times, through leveraging [Faker][faker] providers to generate valid addresses,
telephone numbers, etc.

## pattern

String values generated by a specified regular expression in the `pattern` key.

#### Example

```json synth
{        
  "type": "string",
  "pattern": "I am a (man|woman) with [2-9] friends"
}
```

## uuid

`uuid` generates hyphenated [UUIDs](https://en.wikipedia.org/wiki/Universally_unique_identifier).

This generator has no parameters.

#### Example

```json synth
{        
  "type": "string",
  "uuid": {}
}
```

## faker

Synth has an internal fake data generator that will generate fake data for semantic types such as Names, Addresses, etc.

#### Example

```json synth
{
  "type": "string",
  "faker": {
    "generator": "address"
  }
}
```

Faker offers a variety of different fake data, in different locales and can be leveraged easily from Synth schemas using
the `generator` key. 

#### first_name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "first_name"
	}
}
```

#### last_name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "last_name"
	}
}
```

#### title


```json synth
{
	"type": "string",
	"faker": {
		"generator": "title"
	}
}
```

#### suffix


```json synth
{
	"type": "string",
	"faker": {
		"generator": "suffix"
	}
}
```

#### name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "name"
	}
}
```

#### name_with_title


```json synth
{
	"type": "string",
	"faker": {
		"generator": "name_with_title"
	}
}
```

#### credit_card


```json synth
{
	"type": "string",
	"faker": {
		"generator": "credit_card"
	}
}
```

#### free_email_provider


```json synth
{
	"type": "string",
	"faker": {
		"generator": "free_email_provider"
	}
}
```

#### domain_suffix


```json synth
{
	"type": "string",
	"faker": {
		"generator": "domain_suffix"
	}
}
```

#### free_email


```json synth
{
	"type": "string",
	"faker": {
		"generator": "free_email"
	}
}
```

#### safe_email


```json synth
{
	"type": "string",
	"faker": {
		"generator": "safe_email"
	}
}
```

#### username


```json synth
{
	"type": "string",
	"faker": {
		"generator": "username"
	}
}
```

#### ipv4


```json synth
{
	"type": "string",
	"faker": {
		"generator": "ipv4"
	}
}
```

#### ipv6


```json synth
{
	"type": "string",
	"faker": {
		"generator": "ipv6"
	}
}
```

#### ip


```json synth
{
	"type": "string",
	"faker": {
		"generator": "ip"
	}
}
```

#### mac_address


```json synth
{
	"type": "string",
	"faker": {
		"generator": "mac_address"
	}
}
```

#### color


```json synth
{
	"type": "string",
	"faker": {
		"generator": "color"
	}
}
```

#### user_agent


```json synth
{
	"type": "string",
	"faker": {
		"generator": "user_agent"
	}
}
```

#### rfc_status_code


```json synth
{
	"type": "string",
	"faker": {
		"generator": "rfc_status_code"
	}
}
```

#### valid_status_code


```json synth
{
	"type": "string",
	"faker": {
		"generator": "valid_status_code"
	}
}
```

#### company_suffix


```json synth
{
	"type": "string",
	"faker": {
		"generator": "company_suffix"
	}
}
```

#### company_name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "company_name"
	}
}
```

#### buzzword


```json synth
{
	"type": "string",
	"faker": {
		"generator": "buzzword"
	}
}
```

#### buzzword_muddle


```json synth
{
	"type": "string",
	"faker": {
		"generator": "buzzword_muddle"
	}
}
```

#### buzzword_tail


```json synth
{
	"type": "string",
	"faker": {
		"generator": "buzzword_tail"
	}
}
```

#### catch_phrase


```json synth
{
	"type": "string",
	"faker": {
		"generator": "catch_phrase"
	}
}
```

#### bs_verb


```json synth
{
	"type": "string",
	"faker": {
		"generator": "bs_verb"
	}
}
```

#### bs_adj


```json synth
{
	"type": "string",
	"faker": {
		"generator": "bs_adj"
	}
}
```

#### bs_noun


```json synth
{
	"type": "string",
	"faker": {
		"generator": "bs_noun"
	}
}
```

#### bs


```json synth
{
	"type": "string",
	"faker": {
		"generator": "bs"
	}
}
```

#### profession


```json synth
{
	"type": "string",
	"faker": {
		"generator": "profession"
	}
}
```

#### industry


```json synth
{
	"type": "string",
	"faker": {
		"generator": "industry"
	}
}
```

#### city_prefix


```json synth
{
	"type": "string",
	"faker": {
		"generator": "city_prefix"
	}
}
```

#### city_suffix


```json synth
{
	"type": "string",
	"faker": {
		"generator": "city_suffix"
	}
}
```

#### city_name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "city_name"
	}
}
```

#### country_name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "country_name"
	}
}
```

#### country_code


```json synth
{
	"type": "string",
	"faker": {
		"generator": "country_code"
	}
}
```

#### street_suffix


```json synth
{
	"type": "string",
	"faker": {
		"generator": "street_suffix"
	}
}
```

#### street_name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "street_name"
	}
}
```

#### time_zone


```json synth
{
	"type": "string",
	"faker": {
		"generator": "time_zone"
	}
}
```

#### state_name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "state_name"
	}
}
```

#### state_abbr


```json synth
{
	"type": "string",
	"faker": {
		"generator": "state_abbr"
	}
}
```

#### secondary_address_type


```json synth
{
	"type": "string",
	"faker": {
		"generator": "secondary_address_type"
	}
}
```

#### secondary_address


```json synth
{
	"type": "string",
	"faker": {
		"generator": "secondary_address"
	}
}
```

#### zip_code


```json synth
{
	"type": "string",
	"faker": {
		"generator": "zip_code"
	}
}
```

#### post_code


```json synth
{
	"type": "string",
	"faker": {
		"generator": "post_code"
	}
}
```

#### building_number


```json synth
{
	"type": "string",
	"faker": {
		"generator": "building_number"
	}
}
```

#### latitude


```json synth
{
	"type": "string",
	"faker": {
		"generator": "latitude"
	}
}
```

#### longitude


```json synth
{
	"type": "string",
	"faker": {
		"generator": "longitude"
	}
}
```

#### phone_number


```json synth
{
	"type": "string",
	"faker": {
		"generator": "phone_number"
	}
}
```

#### cell_number


```json synth
{
	"type": "string",
	"faker": {
		"generator": "cell_number"
	}
}
```

#### file_path


```json synth
{
	"type": "string",
	"faker": {
		"generator": "file_path"
	}
}
```

#### file_name


```json synth
{
	"type": "string",
	"faker": {
		"generator": "file_name"
	}
}
```

#### file_extension


```json synth
{
	"type": "string",
	"faker": {
		"generator": "file_extension"
	}
}
```

#### dir_path


```json synth
{
	"type": "string",
	"faker": {
		"generator": "dir_path"
	}
}
```

## date_time

A `date_time` is a variant of the `string` generator type that generates values from a specified range of `date_time`
values. This lets you, for example, generate valid days of the year for an `updated_at` column or a
valid [RFC 2822](https://tools.ietf.org/html/rfc2822) timestamp for an email header field, among others.

You can specify a string as a `date_time` by using the `"date_time": {...}` key/value pair.

#### Example

```json synth
{
  "type": "string",
  "date_time": {
    "format": "%Y-%m-%d",
    "subtype": "naive_date",
    "begin": "2020-01-01",
    "end": "2025-01-01"
  }
}
```

Accepted values for the `"date_time"` key are objects with the following keys:

- `"format"`: a [strftime](https://docs.rs/chrono/0.4.19/chrono/format/strftime/index.html)-style parameter specifying
  the string formatting of the underlying `date_time`
  value.
- `"subtype"`: one of the following
    * `"naive_date"`: when the underlying `date_time` value should be a simple `date` without timezone specification,
    * `"naive_time"`: when the underlying `date_time` value should be a simple `time` without timezone specification,
    * `"naive_date_time"`: when the underlying `date_time` value should be a combined `date` and `time` without timezone
      specification,
    * `"date_time"`: when the underlying `date_time` value should be a combined `date` and `time` *with* timezone
      specification.
- `"begin"` and `"end"`: the lower and upper bounds of the `date_time` value to generate. The formatting of these values
  must adhere to the `strftime`-string specified in the `"format"` field.

#### Example

```json synth
{
  "type": "string",
  "date_time": {
    "format": "%Y-%m-%dT%H:%M:%S",
    "subtype": "naive_date_time",
    "begin": "2015-01-01T00:00:00",
    "end": "2020-01-01T12:00:00"
  }
}
```

## serialized

`serialized` is a variant of the `string` generator type which serializes the output of a child generator into a string.

`serialized` has 2 fields,
- `serializer`: The serializer to be used (currently only `json`)
- `content`: The content to be serialized. This can be any valid Synth generator



#### Example

```json synth
{
    "type": "string",
    "serialized": {
        "serializer": "json",
        "content": {
            "type": "object",
            "username": {
                "type": "string",
                "faker": {
                    "generator": "name"
                }
            }
        }
    }
}
```

## truncated

The `truncated` generator truncates the output of it's inner generator to a fixed length.

If the output of its inner generator is less than or equal to the length, it is left untouched. 

`truncated` has 2 fields,
- `length`: The number of characters to truncate to.
- `content`: The content to be truncated. This can be any Synth generator that yields a String.

#### Example

```json synth
{
  "type": "string",
  "truncated": {
    "content": {
      "type": "string",
      "pattern": "[a-zA-Z0-9]{0, 255}"
    },
    "length": 5
  }
}
```



## categorical

A `categorical` is a variant of the `string` generator type that generates values from a finite set of user-defined
values. You can specify a string as a categorical by using the `"categorical": {...}` key/value pair.

#### Example

```json synth
{
  "type": "string",
  "categorical": {
    "pawn": 8,
    "rook": 2,
    "knight": 2,
    "bishop": 2,
    "queen": 1,
    "king": 1
  }
}
```

The value of the `"categorical"` key must be an object whose:

- keys are the allowed values of the categorical (e.g. `"pawn"`, `"rook"`, etc.),
- values are non-negative integers defining the relative weight of the corresponding variant (e.g. `8`, `2`, etc.).

[faker]: https://faker.readthedocs.io/en/master/
